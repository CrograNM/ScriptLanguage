'''

오셀로 재배치 (백준 13413)

<오셀로 의사코드>
N : 5
o1 : 01100
o2 : 01010

for i(N: 0~4):
	o1[i] 와 o2[i] 비교
	같으면 넘어감
	다르면 해당 인덱스 저장 (리스트 생성 후, 모든 인덱스들 저장됨)
		--> index_list = [2, 3] (2, 3번 인덱스가 서로 다름)
만약 인덱스 리스트의 개수 len이
짝수라면 //2를 하고 출력.
홀수라면 //2를 하고 +1 하고 출력.

----- 위에는 실패 -----
지금 최소 횟수 자체만 구하면 되는 방식으로 구하는 중
7
0000000
0101010
의 경우,
0이 7개인데, 목표 상태는 0:4개, 1:3개이다.
1의 개수가 부족하므로 목표 상태가 되기 위해서는 무조건 바꾸는 행위가 있어야 한다.

4
1100 22
0010 31
의 경우, 목표와 0,1의 개수도 다르고 위치도 바꿔야 한다.

첫번째로, 목표의 0, 1 개수를 위한 색 변경 작업 : 1회에 +1
만약 목표와 0, 1 개수가 동일하다면
두번째로, 위치만 다른 경우 위치 변경 작업: 인덱스 개수 //2

110100
001011 -> 0 1 개수가 같고 자리만 6자리가 다름 -> 최소 3회

'''

T = int(input())
for _ in range(T):
    N = int(input()) # 오셀로 말의 개수

    o1 = input()  # 초기 상태 (string) WBBWW
    o2 = input()  # 목표 상태 (string) WBWBW

    '''
    우선 반복문을 통해 o1의 W,B개수, o2의 W,B개수를 구한다.
    만약 o1 과 o2의 W,B개수가 다른 경우 
    W,B상태를 바꿔주며 총 횟수를 더한다 
        부족한 부분이 매꿔지게 된다. 즉, 
        W7B0 -> W3B4 의 경우 +4번
        W1B3 -> W3B1 의 경우 +2번
        
        ->  W개수를 세고, o1의 W가 부족하면 부족한 만큼(w_o2 - w_o1) +횟수
            W가 많으면, 많은 만큼(w_o1 - w_o2) +횟수 
        
    다시 반복문을 통해 두 객체를 검사하고, 다른 값 마다 카운트를 기록한다
    카운트에 //2 한 값을 총 횟수에 더한다
    '''
    W_o1 = 0
    B_o1 = 0
    W_o2 = 0
    B_o2 = 0
    for i in range(N):
        pass


    # 상태 변화를 위한 리스트 생성 --> ['W', 'B', 'B', 'W', 'W']
    list_o1 = list()
    list_o2 = list()
    for i in range(N):
        list_o1.append(o1[i])
        list_o2.append(o2[i])

    index_list = list()
    for i in range(N):
        if (list_o1[i] != list_o2[i]):
            index_list.append(i)

